```js-engine

const sheetcontainer = document.createElement("div");

const weaponTableContainer = document.createElement('div');
weaponTableContainer.id = 'weapon-table-container';


function updateWeaponTableDOM() {
    weaponTableContainer.innerHTML = '';
    weaponTableContainer.appendChild(renderWeaponTableSection());
}

// ---- TABLE UTILITIES: DRY Table & Cell Helpers ----

// --- DRY Section Header Utility ---
function createSectionHeader(text, size = "2em", color = "#ffc200", extraStyles = {}) {
    const header = document.createElement("div");
    header.textContent = text;
    header.style.fontWeight = "bold";
    header.style.fontSize = size;
    header.style.color = color;
    header.style.margin = "18px 0 6px 0";
    Object.assign(header.style, extraStyles);
    return header;
}



// 1. Creates a full editable table, with optional search bar to add new rows
function createEditableTable({ columns, storageKey, fetchItems, cellOverrides = {} }) {
    let data = JSON.parse(localStorage.getItem(storageKey) || "[]");

    // DOM setup
    const tablecontainer = document.createElement('div');
    tablecontainer.style.padding = '15px';
    tablecontainer.style.border = '3px solid #2e4663';
    tablecontainer.style.borderRadius = '8px';
    tablecontainer.style.backgroundColor = '#325886';
    tablecontainer.style.marginBottom = '20px';
	tablecontainer.style.overflowX = 'auto';
    // Search bar (optional, only if fetchItems provided)
    let searchBar;
    if (fetchItems) {
        searchBar = createSearchBar({
            fetchItems,
            onSelect: (item) => {
                data.push(item);
                saveAndRender();
            }
        });
        tablecontainer.appendChild(searchBar);
    }

    // Table and header
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.marginBottom = '10px';

    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label;
        th.style.textAlign = 'center';
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    table.appendChild(tbody);
    tablecontainer.appendChild(table);

    function save() {
        localStorage.setItem(storageKey, JSON.stringify(data));
    }

    function render() {
        tbody.innerHTML = "";
        data.forEach((rowData, rowIdx) => {
            const row = document.createElement('tr');
            columns.forEach(col => {
                // ----- DRY OVERRIDE HOOK -----
                if (cellOverrides[col.key]) {
                    row.appendChild(cellOverrides[col.key]({
                        rowData,
                        col,
                        rowIdx,
                        data,
                        saveAndRender,
                        save,
                        render,
                    }));
                } else {
                    row.appendChild(
                        createEditableCell({
                            rowData,
                            col,
                            onChange: (val) => {
                                if (col.type === "remove") {
                                    data.splice(rowIdx, 1);
                                } else if (col.type === "checkbox") {
                                    rowData[col.key] = val;
                                } else {
                                    rowData[col.key] = val;
                                }
                                saveAndRender();
                            }
                        })
                    );
                }
            });
            tbody.appendChild(row);
        });
    }


    function saveAndRender() {
        save();
        render();
    }

    // Initial render
    render();

    return tablecontainer;
}

// 2. Renders an editable table cell (supports text, number, checkbox, links, remove)
function createEditableCell({ rowData, col, onChange }) {
    const td = document.createElement('td');
    td.style.textAlign = 'center';

    // --- Remove Button (as before) ---
    if (col.type === "remove") {
        const btn = document.createElement('span');
        btn.textContent = "ðŸ—‘ï¸";
        btn.style.cursor = "pointer";
        btn.onclick = () => onChange();
        td.appendChild(btn);
        return td;
    }

    // --- Checkbox, generic ---
    if (col.type === "checkbox") {
        const checkbox = document.createElement('input');
        checkbox.type = "checkbox";
        checkbox.checked = !!rowData[col.key];
        checkbox.onchange = (e) => onChange(e.target.checked);
        td.appendChild(checkbox);
        return td;
    }

    // --- Link or Text (generic editable) ---
    let span = document.createElement('span');
    if (col.type === "link") {
        span.innerHTML = (rowData[col.key] || "").replace(
            /\[\[(.*?)\]\]/g, '<a class="internal-link" href="$1">$1</a>'
        );
    } else {
        span.textContent = rowData[col.key] || "";
    }
    span.style.cursor = "pointer";
    span.style.display = "inline-block";
    td.onclick = (event) => {
        if (event.target.tagName === "A" || event.target.tagName === "INPUT") return;
        if (td.querySelector('input')) return;
        const input = document.createElement('input');
        input.type = col.type === "number" ? "number" : "text";
        input.value = rowData[col.key] || "";
        input.style.width = "95%";
        input.style.backgroundColor = "#fde4c9";
        input.style.color = "black";
        input.style.caretColor = "black";
        input.onblur = () => onChange(input.value.trim());
        input.onkeydown = (e) => {
            if (e.key === "Enter" || e.key === "Escape") input.blur();
        };
        td.innerHTML = "";
        td.appendChild(input);
        input.focus();
    };
    td.appendChild(span);
    return td;
}




// 3. Optional: Search bar utility for adding new rows
function createSearchBar({ fetchItems, onSelect }) {
    const wrapper = document.createElement('div');
    wrapper.style.marginBottom = "10px";
    wrapper.style.position = "relative"; // For dropdown positioning

    const input = document.createElement('input');
    input.type = "text";
    input.placeholder = "Search...";
    input.style.width = "100%";
    input.style.padding = "5px";
    input.style.backgroundColor = "#fde4c9";
    input.style.color = "black";
    input.style.borderRadius = "5px";
    wrapper.appendChild(input);

    const results = document.createElement('div');
    results.style.backgroundColor = "#fde4c9";
    results.style.color = "black";
    results.style.position = "absolute";
    results.style.left = 0;
    results.style.top = "110%";
    results.style.width = "100%";
    results.style.border = "1px solid #ccc";
    results.style.borderRadius = "0 0 6px 6px";
    results.style.boxShadow = "0 2px 6px rgba(0,0,0,0.1)";
    results.style.display = "none";
    results.style.maxHeight = "200px";
    results.style.overflowY = "auto";
    results.style.zIndex = 999;
    wrapper.appendChild(results);

    input.addEventListener('input', async () => {
        const query = input.value.toLowerCase();
        if (!query) {
            results.style.display = "none";
            results.innerHTML = "";
            return;
        }
        const items = await fetchItems();
        const matches = items.filter(item =>
            (item.name || item.link || "").toLowerCase().includes(query)
        );
        results.innerHTML = "";
        matches.forEach((item, i) => {
            const div = document.createElement('div');
            // Display: remove [[...]]
            let label = (item.name || item.link || "").replace(/\[\[(.*?)\]\]/g, "$1");
            div.textContent = label;
            div.style.cursor = "pointer";
            div.style.padding = "7px 12px";
            div.style.borderBottom = (i < matches.length - 1) ? "1px solid #ccc" : "";
            div.onmouseover = () => div.style.background = "#fdeec2";
            div.onmouseout = () => div.style.background = "inherit";
            div.onclick = () => {
                onSelect(item);
                input.value = "";
                results.style.display = "none";
            };
            results.appendChild(div);
        });
        results.style.display = matches.length ? "block" : "none";
    });

    input.addEventListener('keydown', (e) => {
        if (e.key === "Escape") {
            results.style.display = "none";
            input.value = "";
        }
        if (e.key === "Enter") {
            let first = results.querySelector('div');
            if (first) first.click();
        }
    });

    input.addEventListener('blur', () => setTimeout(() => { results.style.display = "none"; }, 150));

    return wrapper;
}


// 4. For later: helper for multi-character storage keys
function getStorageKey(base, character) {
    return character ? `${base}_${character}` : base;
}



const skillToSpecial = { 
    "Athletics": "STR", "Barter": "CHA", "Big Guns": "END", 
    "Energy Weapons": "PER", "Explosives": "PER", "Lockpick": "PER", 
    "Medicine": "INT", "Melee Weapons": "STR", "Pilot": "PER", 
    "Repair": "INT", "Science": "INT", "Small Guns": "AGI", 
    "Sneak": "AGI", "Speech": "CHA", "Survival": "END", 
    "Throwing": "AGI", "Unarmed": "STR" 
};



//--------------------------------------------------------------------------------------------

const builder = engine.markdown.createBuilder();
const STORAGE_KEY = 'falloutRPGCharacterSheet'; 
const inputs = {};

const saveInputs = () => { 
    const data = Object.fromEntries(
        Object.keys(inputs).map(key => {
            if (!inputs[key]) return null;
            if (inputs[key].type === "checkbox") return [key, inputs[key].checked];
            return [key, inputs[key].value || null];
        }).filter(entry => entry !== null)
    );
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); 
};

const loadInputs = () => { 
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    Object.entries(inputs).forEach(([key, input]) => { 
        if (input.type === "checkbox") input.checked = data[key] ?? false;
        else input.value = data[key] ?? "";
        if (["Maximum HP", "Initiative", "MeleeDamage", "Defense"].includes(key) && input.value.trim() !== "") {
            input.dataset.manual = "true";
        }
    });
    updateDerivedStats();
};

const updateDerivedStats = () => { 
    const end = parseInt(inputs['END']?.value) || 0;
    const lck = parseInt(inputs['LCK']?.value) || 0;
    const per = parseInt(inputs['PER']?.value) || 0;
    const agi = parseInt(inputs['AGI']?.value) || 0;
    const str = parseInt(inputs['STR']?.value) || 0;

    if (!inputs['Maximum HP']?.dataset?.manual) inputs['Maximum HP'].value = end + lck;
    if (!inputs['Initiative']?.dataset?.manual) inputs['Initiative'].value = per + agi;
    if (!inputs['Defense']?.dataset?.manual) inputs['Defense'].value = agi >= 9 ? 2 : 1;

    if (!inputs['MeleeDamage']?.dataset?.manual) {
        let meleeDamage = "-";
        if (str >= 7 && str <= 8) meleeDamage = "+1d6";
        else if (str >= 9 && str <= 10) meleeDamage = "+2d6";
        else if (str >= 11) meleeDamage = "+3d6";
        inputs['MeleeDamage'].value = meleeDamage;
    }
    saveInputs();
};



// --- Helper: read SPECIAL & skills from DOM
function getCharacterStats() { 
    let stats = {}; 
    ["STR", "PER", "END", "CHA", "INT", "AGI", "LCK"].forEach(stat => { 
        let value = parseInt(document.getElementById(stat)?.value) || 0; 
        stats[stat] = value; 
    }); 
    let skills = {}; 
    Object.keys(skillToSpecial).forEach(skill => { 
        let skillValue = parseInt(document.getElementById(skill)?.value) || 0; 
        let tagged = document.getElementById(`${skill}Tag`)?.checked || false; 
        skills[skill] = { 
            value: skillValue, 
            tagged: tagged 
        };
    }); 
    return { stats, skills }; 
}

// --- Helper: calculate TN & Tag for a skill
window.calculateWeaponStats = function(weaponSkill) {
    let { stats, skills } = getCharacterStats();

    if (!skills[weaponSkill]) return { TN: "N/A", Tag: false };

    let skillValue = skills[weaponSkill].value;
    let specialStat = skillToSpecial[weaponSkill];
    let specialValue = stats[specialStat] || 0;

    let calculatedTN = skillValue + specialValue;
    let calculatedTag = skills[weaponSkill].tagged;

    return {
        TN: calculatedTN,
        Tag: calculatedTag
    };
};




function updateWeaponStats() {
    let weapons = JSON.parse(localStorage.getItem("fallout_weapon_table") || "[]");

    weapons.forEach((weapon, index) => {
        let calculatedStats = calculateWeaponStats(weapon.type);

        // Only update TN if it has not been manually entered
        if (weapon.manualTN === undefined) {
            weapon.TN = calculatedStats.TN;
        }

        weapon.Tag = calculatedStats.Tag;
    });

    localStorage.setItem("fallout_weapon_table", JSON.stringify(weapons));
    // Do NOT update DOM here!
    // Leave DOM updating to updateWeaponTableDOM
}

// Helper for manual override handling
const attachManualOverride = (id) => { 
    if (inputs[id]) {
        inputs[id].addEventListener("input", (e) => { 
            if (e.target.value.trim() === "") {
                delete inputs[id].dataset.manual; 
                updateDerivedStats(); 
            } else {
                inputs[id].dataset.manual = "true"; 
            }
            saveInputs();
        });
    }
};

function renderStatsSection() {
    // --- Root container ---
    const section = document.createElement("div");
    section.style.padding = "15px";
    section.style.borderRadius = "8px";
    section.style.background = "#325886";
    section.style.border = "3px solid #2e4663";
    section.style.marginBottom = "20px";
    section.style.display = "grid";
    section.style.gridTemplateColumns = "1fr 1fr";
    section.style.gap = "20px";
    section.style.minWidth = "700px";

// === Character Info ===
    const charInfo = document.createElement("div");
    charInfo.style.border = "1px solid #ccc";
    charInfo.style.padding = "10px";
    charInfo.style.borderRadius = "8px";
    charInfo.style.background = "rgba(255,255,255,0.02)";

    const charTitle = document.createElement("div");
    charTitle.textContent = "Character Info";
    charTitle.style.fontWeight = "bold";
    charTitle.style.fontSize = "22px";
    charTitle.style.color = "#efdd6f";
    charTitle.style.textAlign = "center";
    charTitle.style.paddingBottom = "5px";
    charInfo.appendChild(charTitle);

    const infoGrid = document.createElement("div");
    infoGrid.style.display = "grid";
    infoGrid.style.gridTemplateColumns = "auto 1fr";
    infoGrid.style.gap = "5px";
    infoGrid.style.alignItems = "center";

// input fields
    function addRow(labelText, inputId, type="text", width="100%") {
        const label = document.createElement("label");
        label.textContent = labelText;
        label.style.color = "#FFC200";
        infoGrid.appendChild(label);

        const input = document.createElement("input");
        input.type = type;
        input.id = inputId;
        input.style.width = width;
        input.style.backgroundColor = "#fde4c9";
        input.style.borderRadius = "5px";
        input.style.color = "black";
        infoGrid.appendChild(input);
    }
    addRow("Name:", "Name", "text");
    addRow("Origin:", "Origin", "text");
    addRow("Level:", "Level", "number", "50px");
    addRow("XP Earned:", "XPEarned", "number", "80px");
    addRow("XP to Next Level:", "XPNext", "number", "80px");

    charInfo.appendChild(infoGrid);
    section.appendChild(charInfo);

// === Derived Stats ===
    const derivedStats = document.createElement("div");
    derivedStats.style.border = "1px solid #ccc";
    derivedStats.style.padding = "15px";
    derivedStats.style.borderRadius = "8px";
    derivedStats.style.background = "rgba(255,255,255,0.02)";

    const derivedTitle = document.createElement("div");
    derivedTitle.textContent = "Derived Stats";
    derivedTitle.style.fontWeight = "bold";
    derivedTitle.style.fontSize = "22px";
    derivedTitle.style.color = "#efdd6f";
    derivedTitle.style.textAlign = "center";
    derivedTitle.style.paddingBottom = "5px";
    derivedStats.appendChild(derivedTitle);

// Two-column grid for derived stats and HP/Luck
    const derivedGrid = document.createElement("div");
    derivedGrid.style.display = "grid";
    derivedGrid.style.gridTemplateColumns = "1fr 1fr";
    derivedGrid.style.gap = "10px";

// Left column: Derived Stats
    const leftCol = document.createElement("div");

    function addDerived(labelText, inputId, type="text") {
        const label = document.createElement("label");
        label.textContent = labelText;
        label.style.color = "#FFC200";
        leftCol.appendChild(label);

        const input = document.createElement("input");
        input.type = type;
        input.id = inputId;
        input.style.width = "90%";
        input.style.backgroundColor = "#fde4c9";
        input.style.borderRadius = "5px";
        input.style.color = "black";
        leftCol.appendChild(input);

        leftCol.appendChild(document.createElement("br"));
    }
    addDerived("Melee Damage:", "MeleeDamage");
    addDerived("Defense:", "Defense", "number");
    addDerived("Initiative:", "Initiative", "number");

    derivedGrid.appendChild(leftCol);

// Right column: Luck Points + HP
    const rightCol = document.createElement("div");

// Luck Points
    const luckWrapper = document.createElement("div");
    luckWrapper.style.border = "1px solid #efdd6f";
    luckWrapper.style.padding = "5px";
    luckWrapper.style.display = "grid";
    luckWrapper.style.gridTemplateColumns = "auto 1fr";
    luckWrapper.style.alignItems = "center";
    luckWrapper.style.marginBottom = "5px";

    const luckLabel = document.createElement("label");
    luckLabel.textContent = "Luck Points:";
    luckLabel.style.color = "#FFC200";
    luckWrapper.appendChild(luckLabel);

    const luckInput = document.createElement("input");
    luckInput.type = "number";
    luckInput.id = "LuckPoints";
    luckInput.style.minWidth = "30px";
    luckInput.style.maxWidth = "75px";
    luckInput.style.backgroundColor = "#fde4c9";
    luckInput.style.borderRadius = "5px";
    luckInput.style.color = "black";
    luckWrapper.appendChild(luckInput);
    rightCol.appendChild(luckWrapper);

// HP
    const hpWrapper = document.createElement("div");
    hpWrapper.style.border = "1px solid #efdd6f";
    hpWrapper.style.padding = "5px";
    hpWrapper.style.display = "grid";
    hpWrapper.style.gridTemplateColumns = "auto auto";
    hpWrapper.style.alignItems = "center";
    hpWrapper.style.minHeight = "100px";

// HP Title
    const hpTitle = document.createElement("label");
    hpTitle.textContent = "HP";
    hpTitle.style.gridColumn = "1 / span 2";
    hpTitle.style.textAlign = "center";
    hpTitle.style.color = "#efdd6f";
    hpTitle.style.fontWeight = "bold";
    hpTitle.style.fontSize = "13px";
    hpWrapper.appendChild(hpTitle);

// Max HP
    const maxHpLabel = document.createElement("label");
    maxHpLabel.textContent = "Maximum HP:";
    maxHpLabel.style.color = "#FFC200";
    hpWrapper.appendChild(maxHpLabel);

    const maxHpInput = document.createElement("input");
    maxHpInput.type = "text";
    maxHpInput.id = "Maximum HP";
    maxHpInput.style.minWidth = "20px";
    maxHpInput.style.maxWidth = "50px";
    maxHpInput.style.backgroundColor = "#fde4c9";
    maxHpInput.style.borderRadius = "5px";
    maxHpInput.style.color = "black";
    hpWrapper.appendChild(maxHpInput);

// Current HP
    const currHpLabel = document.createElement("label");
    currHpLabel.textContent = "Current HP:";
    currHpLabel.style.color = "#FFC200";
    hpWrapper.appendChild(currHpLabel);

    const currHpInput = document.createElement("input");
    currHpInput.type = "text";
    currHpInput.id = "CurrentHP";
    currHpInput.style.minWidth = "20px";
    currHpInput.style.maxWidth = "50px";
    currHpInput.style.backgroundColor = "#fde4c9";
    currHpInput.style.borderRadius = "5px";
    currHpInput.style.color = "black";
    hpWrapper.appendChild(currHpInput);

    rightCol.appendChild(hpWrapper);
    derivedGrid.appendChild(rightCol);

    derivedStats.appendChild(derivedGrid);
    section.appendChild(derivedStats);

// === S.P.E.C.I.A.L. Stats ===
    const specialDiv = document.createElement("div");
    specialDiv.style.gridColumn = "span 2";
    specialDiv.style.border = "1px solid #ccc";
    specialDiv.style.padding = "10px";
    specialDiv.style.borderRadius = "8px";
    specialDiv.style.textAlign = "center";
    specialDiv.style.marginTop = "10px";

    const specialTitle = document.createElement("div");
    specialTitle.textContent = "S.P.E.C.I.A.L.";
    specialTitle.style.fontWeight = "bold";
    specialTitle.style.fontSize = "22px";
    specialTitle.style.color = "#efdd6f";
    specialTitle.style.textAlign = "center";
    specialTitle.style.paddingBottom = "5px";
    specialDiv.appendChild(specialTitle);

    const specialRow = document.createElement("div");
    specialRow.style.display = "flex";
    specialRow.style.justifyContent = "space-around";
    specialRow.style.gap = "10px";

    ["STR", "PER", "END", "CHA", "INT", "AGI", "LCK"].forEach(stat => {
        const statBox = document.createElement("div");
        statBox.style.display = "flex";
        statBox.style.flexDirection = "column";
        statBox.style.alignItems = "center";

        const statLabel = document.createElement("label");
        statLabel.textContent = stat;
        statLabel.style.color = "#FFC200";
        statLabel.style.fontWeight = "bold";
        statBox.appendChild(statLabel);

        const statInput = document.createElement("input");
        statInput.type = "number";
        statInput.id = stat;
        statInput.style.width = "40px";
        statInput.style.textAlign = "center";
        statInput.style.backgroundColor = "#fde4c9";
        statInput.style.color = "black";
        statInput.style.borderRadius = "5px";
        statInput.style.border = "1px solid #000";
        statBox.appendChild(statInput);

        specialRow.appendChild(statBox);
    });

    specialDiv.appendChild(specialRow);
    section.appendChild(specialDiv);

// === Skills Section ===
    const skillsDiv = document.createElement("div");
    skillsDiv.style.gridColumn = "span 2";
    skillsDiv.style.border = "1px solid #ccc";
    skillsDiv.style.padding = "5px";
    skillsDiv.style.borderRadius = "8px";
    skillsDiv.style.textAlign = "left";
    skillsDiv.style.marginTop = "10px";

    const skillsTitle = document.createElement("div");
    skillsTitle.textContent = "Skills";
    skillsTitle.style.fontWeight = "bold";
    skillsTitle.style.fontSize = "22px";
    skillsTitle.style.color = "#efdd6f";
    skillsTitle.style.textAlign = "center";
    skillsTitle.style.paddingBottom = "5px";
    skillsDiv.appendChild(skillsTitle);

    const skillsGrid = document.createElement("div");
    skillsGrid.style.display = "grid";
    skillsGrid.style.gridTemplateColumns = "repeat(3, 1fr)";
    skillsGrid.style.gap = "5px";

    const skillToSpecial = { 
        "Athletics": "STR", "Barter": "CHA", "Big Guns": "END", 
        "Energy Weapons": "PER", "Explosives": "PER", "Lockpick": "PER", 
        "Medicine": "INT", "Melee Weapons": "STR", "Pilot": "PER", 
        "Repair": "INT", "Science": "INT", "Small Guns": "AGI", 
        "Sneak": "AGI", "Speech": "CHA", "Survival": "END", 
        "Throwing": "AGI", "Unarmed": "STR" 
    };

    Object.keys(skillToSpecial).forEach(skill => {
        const skillRow = document.createElement("div");
        skillRow.style.display = "flex";
        skillRow.style.alignItems = "center";
        skillRow.style.gap = "1px";
        skillRow.style.justifyContent = "space-between";
        skillRow.style.borderBottom = "1px solid rgba(255,255,255,0.2)";
        skillRow.style.padding = "5px 15px";
        skillRow.style.transition = "background-color 0.3s";

        const skillLabel = document.createElement("label");
        skillLabel.textContent = skill;
        skillLabel.style.color = "#FFC200";
        skillLabel.style.textAlign = "left";
        skillRow.appendChild(skillLabel);

        const specialTag = document.createElement("span");
        specialTag.textContent = `[${skillToSpecial[skill]}]`;
        specialTag.style.flex = "2";
        specialTag.style.color = "white";
        specialTag.style.fontSize = "0.8em";
        skillRow.appendChild(specialTag);

        const tagCheckbox = document.createElement("input");
        tagCheckbox.type = "checkbox";
        tagCheckbox.id = `${skill}Tag`;
        skillRow.appendChild(tagCheckbox);

        const skillInput = document.createElement("input");
        skillInput.type = "number";
        skillInput.id = skill;
        skillInput.style.maxWidth = "40px";
        skillInput.style.backgroundColor = "#fde4c9";
        skillInput.style.color = "black";
        skillInput.style.textAlign = "center";
        skillInput.style.borderRadius = "5px";
        skillRow.appendChild(skillInput);

        skillsGrid.appendChild(skillRow);
    });

    skillsDiv.appendChild(skillsGrid);
    section.appendChild(skillsDiv);



//End of Stats Section Container
    return section;
}




setTimeout(() => { 
    document.querySelectorAll("input").forEach(input => {
        const key = input.getAttribute("id");
        inputs[key] = input;
        input.addEventListener("input", saveInputs);
        if (input.type === "checkbox") input.addEventListener("change", saveInputs);
    });

    // SPECIAL stat listeners
    ["STR", "PER", "END", "CHA", "INT", "AGI", "LCK"].forEach(stat => {
        document.getElementById(stat)?.addEventListener("input", () => {
            updateDerivedStats();
            saveInputs();
            setTimeout(updateWeaponStats, 100);
        });
    });

    // Skills + Tag listeners (condensed into one block)
    ["STR", "PER", "END", "CHA", "INT", "AGI", "LCK"].forEach(stat => {
    document.getElementById(stat)?.addEventListener("input", () => {
        updateDerivedStats();
        saveInputs();
        updateWeaponStats();
        updateWeaponTableDOM();
    });
});
Object.keys(skillToSpecial).forEach(skill => {
    let skillInput = document.getElementById(skill);
    let skillTagInput = document.getElementById(`${skill}Tag`);
    if (skillInput) {
        skillInput.addEventListener("input", () => {
            saveInputs();
            updateWeaponStats();
            updateWeaponTableDOM();
        });
    }
    if (skillTagInput) {
        skillTagInput.addEventListener("change", () => {
            saveInputs();
            updateWeaponStats();
            updateWeaponTableDOM();
        });
    }
});

    ["Maximum HP", "Initiative", "Defense", "MeleeDamage"].forEach(id => attachManualOverride(id));

    loadInputs();
    updateDerivedStats();
}, 100);

//--------------------------------------------------------------------------------------------

function renderCapsContainer() {
    const CAPS_KEY = 'fallout_Caps'; // Future: use getStorageKey('fallout_Caps', currentCharacter)
    let storedValue = localStorage.getItem(CAPS_KEY) || '0';

    const CapsContainer = document.createElement('div');
    CapsContainer.style = "padding:10px;border:3px solid #2e4663;border-radius:8px;background:#325886;display:flex;align-items:center;margin-bottom:10px;width:100%;max-width:200px;gap:15px;";

    const CapsLabel = document.createElement('strong');
    CapsLabel.textContent = 'Caps';
    CapsLabel.style.color = '#EFDD6F';

    const decreaseIcon = document.createElement('span');
    decreaseIcon.textContent = "âˆ’";
    decreaseIcon.style = "cursor:pointer;color:#ffc200;font-size:25px;margin-left:15px";

    const increaseIcon = document.createElement('span');
    increaseIcon.textContent = "+";
    increaseIcon.style = "cursor:pointer;color:#ffc200;font-size:25px;";

    const CapsDisplay = document.createElement('span');
    CapsDisplay.textContent = storedValue;
    CapsDisplay.style = "min-width:30px;text-align:center;color:#fde4c9;cursor:pointer;";

    const CapsInput = document.createElement('input');
    CapsInput.type = 'number';
    CapsInput.style = "width:50px;text-align:center;background:#fde4c9;border:1px solid #fbb4577e;display:none;caret-color:black;color:black;";

    function updateCaps(value) {
        let newValue = Math.max(0, parseInt(value, 10) || 0);
        localStorage.setItem(CAPS_KEY, newValue);
        CapsDisplay.textContent = newValue;
        CapsInput.value = newValue;
    }

    CapsDisplay.onclick = () => {
        CapsInput.value = CapsDisplay.textContent;
        CapsDisplay.style.display = "none";
        CapsInput.style.display = "inline-block";
        CapsInput.focus();
    };
    function exitEditMode(save) {
        if (save) updateCaps(CapsInput.value);
        CapsInput.style.display = "none";
        CapsDisplay.style.display = "inline-block";
    }
    CapsInput.addEventListener("blur", () => exitEditMode(true));
    CapsInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") exitEditMode(true);
        if (e.key === "Escape") exitEditMode(false);
    });

    decreaseIcon.onclick = () => updateCaps(parseInt(CapsDisplay.textContent, 10) - 1);
    increaseIcon.onclick = () => updateCaps(parseInt(CapsDisplay.textContent, 10) + 1);

    CapsContainer.append(CapsLabel, decreaseIcon, CapsDisplay, CapsInput, increaseIcon);

    return CapsContainer;
}
//____________________________________________________________________________________________

// --- Weapon Table Columns ---
const weaponColumns = [
    { label: "Name", key: "link", type: "link" },
    { label: "TN", key: "TN", type: "number" },
    { label: "Tag", key: "Tag", type: "checkbox" },
    { label: "Damage", key: "damage", type: "text" },
    { label: "Rate", key: "rate", type: "text" },
    { label: "Effects", key: "damage_effects", type: "link" },
    { label: "Qualities", key: "qualities", type: "link" },
    { label: "Ammo", key: "ammo", type: "text" },
    { label: "Type", key: "type", type: "text" },
    { label: "Damage Type", key: "dmgtype", type: "text" },
    { label: "Range", key: "range", type: "text" },
    { label: "Weight", key: "weight", type: "text" },
    { label: "Cost", key: "cost", type: "text" },
    { label: "Remove", type: "remove" }
];

// --- Custom Cell Overrides for TN and Tag ---
function weaponCellOverrides() {
    return {
        TN: ({ rowData, col, rowIdx, data, saveAndRender }) => {
            let locked = !!rowData.manualTN;
            let value = locked
                ? rowData.TN
                : (typeof calculateWeaponStats === "function" && rowData.type
                    ? calculateWeaponStats(rowData.type).TN
                    : rowData.TN);

            const td = document.createElement('td');
            td.style.textAlign = "center";
            td.textContent = value ?? "";

            td.onclick = (event) => {
                if (td.querySelector('input')) return;
                const input = document.createElement('input');
                input.type = "number";
                input.value = value ?? "";
                input.style.width = "95%";
                input.style.backgroundColor = "#fde4c9";
                input.style.color = "black";
                input.style.caretColor = "black";
                input.onblur = saveInput;
                input.onkeydown = (e) => { if (e.key === "Enter" || e.key === "Escape") input.blur(); };

                function saveInput() {
                    let newValue = input.value.trim();
                    if (newValue !== "" && newValue !== String(value)) {
                        rowData.TN = Number(newValue);
                        rowData.manualTN = true; // lock future auto-update
                    } else if (newValue === "") {
                        delete rowData.manualTN; // unlock
                        if (rowData.type && typeof calculateWeaponStats === "function") {
                            rowData.TN = calculateWeaponStats(rowData.type).TN;
                        }
                    }
                    saveAndRender();
                }
                td.innerHTML = "";
                td.appendChild(input);
                input.focus();
            };
            return td;
        },
        Tag: ({ rowData, col, rowIdx, data, saveAndRender }) => {
            let locked = !!rowData.manualTag;
            let value = locked
                ? rowData.Tag
                : (typeof calculateWeaponStats === "function" && rowData.type
                    ? calculateWeaponStats(rowData.type).Tag
                    : !!rowData.Tag);

            const td = document.createElement('td');
            td.style.textAlign = "center";
            const checkbox = document.createElement('input');
            checkbox.type = "checkbox";
            checkbox.checked = !!value;
            checkbox.onclick = () => {
                rowData.Tag = checkbox.checked;
                rowData.manualTag = true; // lock
                saveAndRender();
            };
            // Right-click to clear override and return to auto
            td.oncontextmenu = (e) => {
                e.preventDefault();
                delete rowData.manualTag;
                if (rowData.type && typeof calculateWeaponStats === "function") {
                    rowData.Tag = calculateWeaponStats(rowData.type).Tag;
                }
                saveAndRender();
            };
            td.appendChild(checkbox);
            return td;
        }
    }
}

// --- Fetch and Parse Weapons ---
let cachedWeaponData = null;
async function fetchWeaponData() {
    if (cachedWeaponData) return cachedWeaponData;
    const WEAPONS_FOLDER = "Fallout-RPG/Items/Weapons";
    let allFiles = await app.vault.getFiles();
    let weaponFiles = allFiles.filter(file => file.path.startsWith(WEAPONS_FOLDER));
    let weapons = await Promise.all(weaponFiles.map(async (file) => {
        let content = await app.vault.read(file);
        let stats = {
            link: `[[${file.basename}]]`, type: "N/A", damage: "N/A",
            damage_effects: "N/A", dmgtype: "Unknown", fire_rate: "N/A",
            range: "N/A", qualities: "N/A", ammo: "N/A", weight: "N/A",
            cost: "N/A", rate: "N/A"
        };
        let statblockMatch = content.match(/```statblock([\s\S]*?)```/);
        if (!statblockMatch) return stats;
        let statblockContent = statblockMatch[1].trim();
        const patterns = {
            name: /name:\s*(.+)/i,
            type: /type:\s*(.+)/i,
            damage: /damage_rating:\s*(.+)/i,
            damage_effects: /damage_effects:\s*(.+)/i,
            dmgtype: /damage_type:\s*(.+)/i,
            fire_rate: /fire_rate:\s*(.+)/i,
            range: /range:\s*(.+)/i,
            qualities: /qualities:\s*(.+)/i,
            ammo: /ammo:\s*(.+)/i,
            weight: /weight:\s*(.+)/i,
            cost: /cost:\s*(.+)/i,
            rate: /rate:\s*(.+)/i
        };
        for (const [key, pattern] of Object.entries(patterns)) {
            let result = statblockContent.match(pattern);
            if (result) stats[key] = result[1].trim().replace(/"/g, '');
        }
        return stats;
    }));
    cachedWeaponData = weapons.filter(w => w);
    return cachedWeaponData;
}

// --- DRY Weapon Table Section ---
function renderWeaponTableSection() {

    return createEditableTable({
        columns: weaponColumns,
        storageKey: "fallout_weapon_table",
        fetchItems: fetchWeaponData,
        cellOverrides: weaponCellOverrides()
    });
}



//--------------------------------------------------------------------------------------------

// --- AMMO SECTION (DRY TABLE VERSION) ---

const AMMO_STORAGE_KEY = getStorageKey("fallout_ammo_table"); // use your helper if multi-char
const AMMO_SEARCH_FOLDERS = ["Fallout-RPG/Items/Ammo"];
const AMMO_DESCRIPTION_LIMIT = 0;

let cachedAmmoData = null;
async function fetchAmmoData() {
    if (cachedAmmoData) return cachedAmmoData;
    let allFiles = await app.vault.getFiles();
    let ammoFiles = allFiles.filter(file => AMMO_SEARCH_FOLDERS.some(folder => file.path.startsWith(folder)));
    let ammoItems = await Promise.all(ammoFiles.map(async (file) => {
        let content = await app.vault.read(file);
        let stats = {
            name: `[[${file.basename}]]`,
            qty: "1",
            description: "No description available"
        };
        let statblockMatch = content.match(/```statblock([\s\S]*?)```/);
        if (!statblockMatch) return stats;
        let statblockContent = statblockMatch[1].trim();
        let descMatch = statblockContent.match(/(?:description:|desc:)\s*(.+)/i);
        if (descMatch) {
            stats.description = descMatch[1].trim().replace(/\"/g, '');
            if (stats.description.length > AMMO_DESCRIPTION_LIMIT)
                stats.description = stats.description.substring(0, AMMO_DESCRIPTION_LIMIT) + "...";
        }
        return stats;
    }));
    cachedAmmoData = ammoItems.filter(g => g);
    return cachedAmmoData;
}

// ---- Table columns for ammo ----
const ammoColumns = [
    { label: "Name", key: "name", type: "link" },
    { label: "Qty", key: "qty", type: "number" },
    { label: "Description", key: "description", type: "link" },
    { label: "Remove", type: "remove" }
];

// ---- AMMO TABLE SECTION ----
function renderAmmoTableSection() {
    return createEditableTable({
        columns: ammoColumns,
        storageKey: AMMO_STORAGE_KEY,
        fetchItems: fetchAmmoData   // <--- THIS automatically gives you the DRY search bar!
    });
}
//--------------------------------------------------------------------------------------------

// ---- ARMOR SECTION (DRY CARD GRID, MOBILE-FIRST, FLEXIBLE FOR DESKTOP LAYOUT) ----

const ARMOR_STORAGE_KEY = "fallout_armor_data";
const ARMOR_FOLDERS = [
    "Fallout-RPG/Items/Apparel/Armor",
    "Fallout-RPG/Items/Apparel/Clothing",
    "Fallout-RPG/Items/Apparel/Headgear",
    "Fallout-RPG/Items/Apparel/Outfits",
    "Fallout-RPG/Items/Apparel/Power Armor",
    "Fallout-RPG/Items/Apparel/Robot Armor"
];
const ARMOR_SECTIONS = ["Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "Outfit"];
const POISON_DR_KEY = "fallout_poison_dr";

// Mapping to match â€œlocationsâ€ fields from YAML to display slots
function matchesSection(locations, section) {
    const mapping = {
        "Arms": ["Left Arm", "Right Arm"], "Arm": ["Left Arm", "Right Arm"],
        "Legs": ["Left Leg", "Right Leg"], "Leg": ["Left Leg", "Right Leg"],
        "Torso": ["Torso"], "Main Body": ["Torso"],
        "Head": ["Head"], "Optics": ["Head"],
        "Thruster": ARMOR_SECTIONS, "All": ARMOR_SECTIONS,
        "Arms, Legs, Torso": ["Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "Outfit"],
        "Head, Arms, Legs, Torso": ARMOR_SECTIONS
    };
    if (typeof locations !== "string") return false;
    if (mapping.hasOwnProperty(locations.trim()))
        return mapping[locations.trim()].includes(section);
    return false;
}

// Async fetch & parse all armor items, filter for a given slot/section
let cachedArmorData = {};
async function fetchArmorData(section) {
    if (cachedArmorData[section]) return cachedArmorData[section];
    let allFiles = await app.vault.getFiles();
    let armorFiles = allFiles.filter(file =>
        ARMOR_FOLDERS.some(folder => file.path.startsWith(folder) || file.path === folder)
    );
    let armors = await Promise.all(armorFiles.map(async (file) => {
        let content = await app.vault.read(file);
        let stats = { link: file.basename, physdr: "0", raddr: "0", endr: "0", hp: "0", locations: "Unknown" };
        let statblockMatch = content.match(/```statblock([\s\S]*?)```/);
        if (!statblockMatch) return stats;
        let statblockContent = statblockMatch[1].trim();
        function extract(pattern) {
            let m = statblockContent.match(pattern);
            return m ? m[1].trim() : "0";
        }
        stats.hp = extract(/hp:\s*(\d+)/i);
        stats.locations = extract(/locations:\s*"([^"]+)"/i);

        // Extract DRs
        let lines = statblockContent.split("\n"), inside = false, curr = "";
        for (let line of lines) {
            line = line.trim();
            if (line.startsWith("dmg resistances:")) { inside = true; continue; }
            if (inside) {
                let name = line.match(/- name:\s*"?(Physical|Energy|Radiation)"?/i);
                if (name) { curr = name[1]; continue; }
                let desc = line.match(/desc:\s*"?(.*?)"?$/i);
                if (desc && curr) {
                    let val = desc[1].trim() || "0";
                    if (curr === "Physical") stats.physdr = val;
                    if (curr === "Energy") stats.endr = val;
                    if (curr === "Radiation") stats.raddr = val;
                    curr = "";
                }
            }
        }
        return stats;
    }));
    cachedArmorData[section] = armors.filter(a => matchesSection(a.locations, section));
    return cachedArmorData[section];
}

// LocalStorage helpers
function saveArmorData(section, data) {
    localStorage.setItem(`${ARMOR_STORAGE_KEY}_${section}`, JSON.stringify(data));
}
function loadArmorData(section) {
    let d = localStorage.getItem(`${ARMOR_STORAGE_KEY}_${section}`);
    return d ? JSON.parse(d) : { physdr: "", raddr: "", endr: "", hp: "", apparel: "" };
}

// --- Card rendering for a single slot (head, torso, etc) ---
function renderArmorCard(section) {
    // Container card
    let card = document.createElement('div');
    card.className = "armor-card"; // for future layout CSS!
    card.style.background = "#325886";
    card.style.border = '3px solid #2e4663';
    card.style.borderRadius = "8px";
    card.style.padding = "10px";
    card.style.margin = "8px";
    card.style.boxShadow = "0 2px 12px rgba(0,0,0,0.14)";
    card.style.minWidth = "250px";
    card.style.flex = "1 1 250px";
	 card.style.marginBottom = '10px';
    card.style.alignItems = 'left';

    card.style.caretColor = 'black';
    
    // Title
    let title = document.createElement("div");
    title.textContent = section;
    title.style.color = '#ffe974';
    title.style.fontWeight = 'bold';
    title.style.fontSize = '1.7em';
    title.style.textAlign = 'center';
    title.style.marginBottom = '7px';
    card.appendChild(title);

    // DR + HP grid
    let statGrid = document.createElement('div');
    statGrid.style.display = 'grid';
    statGrid.style.gridTemplateColumns = "repeat(4, 1fr)";
    statGrid.style.background = "#325886";
    statGrid.style.padding = "10px 0";
    statGrid.style.borderRadius = "5px 5px 0 0";
    statGrid.style.border = '2px solid #2e4663'
    statGrid.style.justifyContent = "center";

    // Field mapping
    let labels = [ ['Phys. DR','physdr'], ['En. DR','endr'], ['Rad. DR','raddr'], ['HP','hp'] ];
    let inputs = {};

    labels.forEach(([label, key]) => {
        let c = document.createElement('div');
        c.style.display = "flex";
        c.style.flexDirection = "column";
        c.style.alignItems = "center";
        c.style.justifyContent = "center";
        let l = document.createElement('span');
        l.textContent = label;
        l.style.color = "#ffc200";
        l.style.fontWeight = "bold";
        l.style.marginBottom = "2px";
        l.style.fontSize = "1em";
        let input = document.createElement('input');
        input.type = 'text';
        input.style.width = "90%";
        input.style.textAlign = "center";
        input.style.background = "#fde4c9";
        input.style.border = "1px solid #e5c96e";
        input.style.borderRadius = "4px";
        input.style.color = "black";
        inputs[key] = input;
        c.appendChild(l); c.appendChild(input);
        statGrid.appendChild(c);
    });

    card.appendChild(statGrid);

    // Apparel/armor markdown field (click-to-edit)
    let apparelDisplay = document.createElement("div");
    apparelDisplay.style.background = "#2e4663";
    apparelDisplay.style.color = "#ffe974";
    apparelDisplay.style.fontWeight = "bold";
    apparelDisplay.style.textAlign = "center";
    apparelDisplay.style.padding = "6px";
    apparelDisplay.style.margin = "0 0 6px 0";
    apparelDisplay.style.borderRadius = "0 0 7px 7px";
    apparelDisplay.style.fontSize = "1.13em";
    apparelDisplay.style.cursor = "text";

    let apparelInput = document.createElement("input");
    apparelInput.type = "text";
    apparelInput.style.width = "100%";
    apparelInput.style.display = "none";
    apparelInput.style.background = "#fde4c9";
    apparelInput.style.textAlign = "center";
    apparelInput.style.color = "black";
    apparelInput.style.borderRadius = "0 0 7px 7px";

    function updateApparelDisplay() {
        let fresh = loadArmorData(section);
        let val = (typeof fresh.apparel === "string" ? fresh.apparel : "");
        apparelDisplay.innerHTML = val.trim() !== "" ?
            val.replace(/\[\[(.*?)\]\]/g, '<a class="internal-link" href="$1">$1</a>') :
            '(Click to edit)';
        apparelInput.value = val;
    }

    apparelDisplay.onclick = () => {
        apparelDisplay.style.display = "none";
        apparelInput.style.display = "block";
        apparelInput.focus();
    };
    apparelInput.onblur = () => {
        let fresh = loadArmorData(section);
        fresh.apparel = apparelInput.value.trim();
        saveArmorData(section, fresh);
        updateApparelDisplay();
        apparelDisplay.style.display = "block";
        apparelInput.style.display = "none";
    };

    card.appendChild(apparelDisplay);
    card.appendChild(apparelInput);

    // DRY Search Bar
    let searchBar = createSearchBar({
        fetchItems: async () => await fetchArmorData(section),
        onSelect: (armor) => {
            // Fill in all the stats as before
            inputs.physdr.value = armor.physdr;
            inputs.raddr.value = armor.raddr;
            inputs.endr.value = armor.endr;
            inputs.hp.value = armor.hp;
            apparelInput.value = `[[${armor.link}]]`;
            let newData = {
                physdr: armor.physdr, raddr: armor.raddr,
                endr: armor.endr, hp: armor.hp,
                apparel: `[[${armor.link}]]`
            };
            saveArmorData(section, newData);
            updateApparelDisplay();
        }
    });
    card.appendChild(searchBar);

    // Initial load
        let stored = loadArmorData(section);
        labels.forEach(([_, key]) => { inputs[key].value = stored[key] || ""; });
        updateApparelDisplay();
   

    // Storage sync
    labels.forEach(([_, key]) => {
        inputs[key].addEventListener('input', () => {
            let stored = loadArmorData(section);
            stored[key] = inputs[key].value;
            saveArmorData(section, stored);
        });
    });
    apparelInput.addEventListener('input', () => {
        let stored = loadArmorData(section);
        stored.apparel = apparelInput.value;
        apparelDisplay.innerHTML = stored.apparel.replace(/\[\[(.*?)\]\]/g, '<a class="internal-link" href="$1">$1</a>');
        saveArmorData(section, stored);
    });

   

    return card;
}

// --- Poison DR bar (always top of armor section) ---
function renderPoisonDRBar() {
    let wrap = document.createElement('div');
    wrap.style.display = "flex";
    wrap.style.alignItems = "center";
    wrap.style.background = "#325886";
    wrap.style.border = "2px solid #2e4663";
    wrap.style.borderRadius = "8px";
    wrap.style.padding = "7px 12px";
    wrap.style.margin = "8px";
    wrap.style.maxWidth = "350px";
    let label = document.createElement('span');
    label.textContent = "Poison DR";
    label.style.color = "#ffe974";
    label.style.fontWeight = "bold";
    label.style.marginRight = "10px";
    let input = document.createElement('input');
    input.type = "text";
    input.value = localStorage.getItem(POISON_DR_KEY) || "";
    input.style.background = "#fde4c9";
    input.style.color = "black";
    input.style.textAlign = "center";
    input.style.borderRadius = "5px";
    input.style.padding = "2px 12px";
    input.style.marginLeft = "5px";
    input.addEventListener('input', () => {
        localStorage.setItem(POISON_DR_KEY, input.value);
    });
    wrap.appendChild(label);
    wrap.appendChild(input);
    return wrap;
}

// --- FULL ARMOR SECTION GRID ---
function renderArmorSectionGrid() {
    let container = document.createElement('div');
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.alignItems = "flex-start";
    container.style.width = "100%";
    container.style.gap = "8px";
    // Poison DR at top
    container.appendChild(renderPoisonDRBar());
    // The cards grid (future: wrap with a desktop-positioning container)
    let grid = document.createElement('div');
    grid.className = "armor-cards-grid";
    grid.style.display = "grid";
    grid.style.gridTemplateColumns = "repeat(auto-fit, minmax(270px, 1fr))";
    grid.style.gap = "10px";
    ARMOR_SECTIONS.forEach(section => grid.appendChild(renderArmorCard(section)));
    container.appendChild(grid);
    return container;
}



/* 
    -- HOW TO SWITCH TO DESKTOP "AROUND VAULT BOY" LAYOUT --
    - Add a .armor-cards-grid class in your CSS for desktop screens that uses absolute positioning, or CSS grid, to place each .armor-card around an image.
    - On mobile, let it stay stacked in a grid as here.
    - All JS remains unchanged!
*/


//--------------------------------------------------------------------------------------------

// ---- GEAR SECTION (DRY TABLE VERSION) ----

const GEAR_STORAGE_KEY = getStorageKey("fallout_gear_table");
const GEAR_SEARCH_FOLDERS = [
    "Fallout-RPG/Items/Apparel",
    "Fallout-RPG/Items/Consumables",
    "Fallout-RPG/Items/Tools and Utilities",
    "Fallout-RPG/Items/Weapons",
    "Fallout-RPG/Perks/Book Perks"
];
const GEAR_DESCRIPTION_LIMIT = 100;

let cachedGearData = null;
async function fetchGearData() {
    if (cachedGearData) return cachedGearData;
    let allFiles = await app.vault.getFiles();
    let gearFiles = allFiles.filter(file =>
        GEAR_SEARCH_FOLDERS.some(folder => file.path.startsWith(folder))
    );
    let gearItems = await Promise.all(gearFiles.map(async (file) => {
        let content = await app.vault.read(file);
        let stats = {
            name: `[[${file.basename}]]`,
            qty: "1",
            cost: "",
            selected: false
        };
        let statblockMatch = content.match(/```statblock([\s\S]*?)```/);
        if (!statblockMatch) return stats;
        let statblockContent = statblockMatch[1].trim();

        let costMatch = statblockContent.match(/cost:\s*(.+)/i);
        if (costMatch) {
            stats.cost = costMatch[1].trim().replace(/\"/g, '');
        }
        return stats;
    }));
    cachedGearData = gearItems.filter(g => g);
    return cachedGearData;
}

// ---- Table columns for gear ----
const gearColumns = [
    { label: "", key: "selected", type: "checkbox" }, // Equipped/important
    { label: "Name", key: "name", type: "link" },
    { label: "Qty", key: "qty", type: "number" },
    { label: "Cost", key: "cost", type: "text" },
    { label: "Remove", type: "remove" }
];

// ---- GEAR TABLE SECTION ----
function renderGearTableSection() {
    return createEditableTable({
        columns: gearColumns,
        storageKey: GEAR_STORAGE_KEY,
        fetchItems: fetchGearData   // DRY search bar!
    });
}

//--------------------------------------------------------------------------------------------

const PERK_STORAGE_KEY = "fallout_perk_table";
const PERK_SEARCH_FOLDERS = [
    "Fallout-RPG/Perks/Core Rulebook",
    "Fallout-RPG/Perks/Settlers",
    "Fallout-RPG/Perks/Wanderers",
    "Fallout-RPG/Perks/Weapons",
    "Fallout-RPG/Perks/Book Perks"
];
const PERK_DESCRIPTION_LIMIT = 999999;

let cachedPerkData = null;
async function fetchPerkData() {
    if (cachedPerkData) return cachedPerkData;

    let allFiles = await app.vault.getFiles();
    let perkFiles = allFiles.filter(file => PERK_SEARCH_FOLDERS.some(folder => file.path.startsWith(folder)));

    let perkItems = await Promise.all(perkFiles.map(async (file) => {
        let content = await app.vault.read(file);

        let stats = {
            name: `[[${file.basename}]]`,
            qty: "1", // Default rank
            description: "No description available"
        };

        let rankMatch = content.match(/Ranks?:\s*(\d+)/i);
        if (rankMatch) stats.qty = rankMatch[1];

        let descMatch = content.match(/(?:description:|desc:)\s*["']?([^"\n]+)["']?/i);
        if (descMatch) {
            stats.description = descMatch[1].trim();
        } else {
            // Fallback: get everything after "Ranks:"
            let descStart = content.indexOf("Ranks:");
            if (descStart !== -1) {
                let descContent = content.substring(descStart).split("\n").slice(1).join(" ").trim();
                stats.description = descContent.length > PERK_DESCRIPTION_LIMIT 
                    ? descContent.substring(0, PERK_DESCRIPTION_LIMIT) + "..."
                    : descContent;
            }
        }

        return stats;
    }));

    cachedPerkData = perkItems.filter(g => g);
    return cachedPerkData;
}

const perkColumns = [
    { label: "Name", key: "name", type: "link" },         // Obsidian link, editable on cell except link click
    { label: "Rank", key: "qty", type: "number" },         // Editable
    { label: "Description", key: "description", type: "link" }, // Editable, full text
    { label: "Remove", type: "remove" }                    // Remove button
];

function renderPerkTableSection() {
    return createEditableTable({
        columns: perkColumns,
        storageKey: PERK_STORAGE_KEY,
        fetchItems: fetchPerkData
    });
}

//--------------------------------------------------------------------------------------------

sheetcontainer.appendChild(renderStatsSection());
sheetcontainer.appendChild(renderCapsContainer());

sheetcontainer.appendChild(createSectionHeader("Weapons"));
sheetcontainer.appendChild(weaponTableContainer);

sheetcontainer.appendChild(createSectionHeader("Ammo"));
sheetcontainer.appendChild(renderAmmoTableSection());

sheetcontainer.appendChild(createSectionHeader("Armor"));
sheetcontainer.appendChild(renderArmorSectionGrid());

sheetcontainer.appendChild(createSectionHeader("Gear"));
sheetcontainer.appendChild(renderGearTableSection());

sheetcontainer.appendChild(createSectionHeader("Perks"));
sheetcontainer.appendChild(renderPerkTableSection());
updateWeaponTableDOM();
return sheetcontainer;


```
